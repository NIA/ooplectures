\documentclass[a4paper, 14pt, titlepage]{extarticle}
  \usepackage{cmap}
  \usepackage[hidelinks,pdftex,unicode]{hyperref}
  \usepackage{mathtext} % для кириллицы в формулах
  \usepackage[T2A]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage[english,russian]{babel}
  \usepackage{indentfirst}
  \usepackage{cite}
  \usepackage{amsmath} % для \eqref
  \usepackage{amssymb} % для \leqslant
  \usepackage{amsthm} % для \pushQED
  \usepackage{color} % пока только для TODO:
  \usepackage[pdftex]{graphicx}
  \usepackage{subfig}
  \usepackage{numprint}
  \usepackage[left=3cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
  \usepackage{datetime}
  \usepackage{ulem} % красивые подчёркивания...
    \normalem % ...но вернуть обратно курсив в \em, \emph
  \graphicspath{{../img/}{../../img/}}
  \frenchspacing

  \DeclareSymbolFont{T2Aletters}{T2A}{cmr}{m}{it} % кириллица в формулах курсивом

  \addto\captionsrussian{
    \renewcommand\contentsname{Содержание}
    % перекрываю \refname, чтобы список литературы сам добавлял себя в оглавление
    \let\oldrefname\refname
    \renewcommand\refname{\addcontentsline{toc}{section}{\oldrefname}\oldrefname}
  }

  \newcommand{\underscore}[1]{\hbox to#1{\hrulefill}}
  \newcommand{\todo}[1]{\textbf{\textcolor{red}{TODO: #1}}}
  \newcommand{\note}[1]{\textit{Примечание: #1}}
  \newcommand{\eng}[1]{{\English #1}}

  % обёртка с моими настройками поверх figure:
  % \begin{myfigure}{подпись}{fig:label} ... \end{myfigure}
  \newenvironment{myfigure}[2]%
    {\pushQED{\caption{#1} \label{#2}} % push caption & label
     \begin{figure}[!htb]\centering } %
    {  \popQED % pop caption & label
     \end{figure}}

  % вставка картинки: \figure[params]{подпись}{file}
  % создаёт label вида fig:file
  \newcommand{\includefigure}[3][]{
    \begin{myfigure}{#2}{fig:#3}
      \includegraphics[#1]{#3}
    \end{myfigure}
  }

  % вставка subfigure внутри myfigure:
  % \subfigure[params]{подпись}{file}
  \newcommand{\subfigure}[3][]{
    \subfloat[#2]{\label{fig:#3}\includegraphics[#1]{#3}}
  }

  \newcommand{\vect}[1]{\vec{#1}} % единое выделение векторов (стрелкой)
  \newcommand{\matx}[1]{\mathbf{#1}} % единое выделение матриц (полужирным)
  \newcommand{\transposed}{\top} % единый знак транспонирования (U+22A4 down tack)
  \renewcommand{\le}{\leqslant} % <= с наклонной нижней перекладиной
  \renewcommand{\ge}{\geqslant} % >= с наклонной нижней перекладиной

  \linespread{1.3}

  % русские буквы для списков и частей рисунка
  \renewcommand{\theenumii}{(\asbuk{enumii})}
  \renewcommand{\labelenumii}{\asbuk{enumii})}
  \renewcommand{\thesubfigure}{\asbuk{subfigure}}

  \setcounter{tocdepth}{3} % глубина оглавления

  \bibliographystyle{gost780u}

  \hyphenation{англ} % убрать перенос в этом сокращении

  % алиас и настройки для numprint
  \newcommand{\num}[1]{\numprint{#1}}
  \npthousandsep{\,}
  \npthousandthpartsep{}
  \npdecimalsign{,}

  \newcommand{\checkdate}[3]{({\Russian дата обращения: \formatdate{#1}{#2}{#3}})}

  % выделение ещё более важных моментов, чем \emph
  \newcommand{\strong}[1]{\textbf{#1}}
  % подчёркивание определяемого в определении
  \newcommand{\define}[1]{\uwave{#1}}


  % общий способ написания "то есть": сокращённый или нет
  \newcommand{\ie}{т.~е.~}

  % участок с увеличенными полями
  \newenvironment{indented}%
    { \begingroup %
        \noindent %
        \leftskip2em %
        \rightskip\leftskip }%
    { \par\endgroup }

  % выделение примеров
  \newenvironment{example}%
    { \begin{indented} %
        \small %
        \textbf{\underline{Пример:}} }%
    { \end{indented} }

  % выделение дополнительной, "продвинутой" информации, необязательной при первом прочтении
  \newenvironment{extrainfo}%
    { \begin{indented} %
        \small %
        \textbf{\textcircled{\footnotesize i}} }%
    { \end{indented} }

  \author{И.\,А.\,Новиков}
  \title{Лекция <<ООП в Ruby и Java>>}

\begin{document}

%----------------------- титульный лист ------------------------

  \thispagestyle{empty}
  \maketitle

  \newpage

  \section{Зачем П~--- ОО?}

  Или, говоря по-русски, зачем нужно объектно-ориентированное программирование (ООП)?

  Затем, что таково человеческое мышление:
  \begin{itemize}
    \item Компьютеру проще работать с \strong{числами}, адресами, инструкциями, в лучшем случае~--- с процедурами.
    \item Человеку же привычнее выделять в окружающей реальности \strong{объекты}, путём абстракции
    выделять их свойства и способы взаимодействия с~ними, а~также выделять общее и
    \strong{классифицировать}.
  \end{itemize}

  Именно поэтому языки низкого уровня (\ie наиболее близкие к машинному представлению кода) обычно
  процедурные: С, Pascal, Fortran; а языки высокого уровня (ЯВУ) чаще объектно-ориентированные:
  \footnote{хотя есть ещё функциональные и логические! Не стоит про них забывать.}
  C++, C\#, Java, Python, Ruby...

  \section{Основные понятия. Принцип Абстракции}

  Итак, человек выделяет объекты, \ie отделяет тот или иной объект от остальной реальности (и от
  других объектов, в частности). Общее определение объекта дать сложно, для программирования же
  важно, что объект~--- это сущность, чётко отделяемая как от других сущностей, так и от себе
  подобных, и имеющая вполне определённые \strong{свойства} и \strong{способы поведения}.

  Важно то, что человек никогда не пытается при осознании объекта выделить \emph{все} его свойства и
  методы поведения (это и невозможно), а сосредотачивается только на тех, которые интересуют его в
  данный момент, отбрасывая остальные.

  \begin{example}
    Держа в руках яблоко и собираясь его съесть, человек думает о его вкусе, цвете и, возможно,
    массе и калорийности, но его вовсе не интересует его электрический заряд, спектральный состав,
    а~также тот факт, что его можно выкинуть в окно, а не съесть.
  \end{example}

  Это и лежит в основе \define{принципа абстракции}: при описании объектов в ООП довольствуются
  минимальным необходимым набором свойств и методов поведения, отбрасывая остальные.

  Среди рассматриваемых объектов можно выделить такие, у которых набор свойств и методов одинаков, а
  отличаются только значения свойств. Объекты такие совершенно одинаковы с точки зрения взаимодействия % непрозрачно
  с ними. Множество таких объектов называют \define{классом}.

  Важно отметить, что так как набор свойств и методов у объектов одного класса одинаков, то можно,
  не меняя смысла, говорить как о наборе свойств/методов \emph{объекта}, так и о наборе
  свойств/методов его класса.

  \begin{example}
    \emph{Вася}~--- объект класса \emph{Человек}. У него есть такие свойства, как \emph{имя} и
    \emph{возраст}. Логично, что \emph{имя} и \emph{возраст} есть также и у \emph{Пети}, и у
    \emph{Насти}, и вообще у всех объектов класса \emph{Человек}. Поэтому можно сказать, что
    \emph{имя, возраст}~--- это не просто свойства \emph{Васи, Пети и Насти}~--- это свойства
    \emph{Человека}, \ie класса.
  \end{example}

  Поскольку не бывает объектов, не принадлежащих ни к какому классу, то вообще не принято говорить о
  свойствах и методах \emph{объекта}~--- вместо этого говорят о свойствах и методах \emph{класса},
  \ie о свойствах и методах, которыми обладают все без исключения объекты этого класса.

  Итак, для того, чтобы определить класс, необходимо задать его имя, список его свойств, методов и
  способ создания новых объектов (точнее~--- их инициализации, \ie установки всех свойств в
  начальные значения и произведения некоторых стартовых действий, применения настроек). Этот способ
  сам является особым методом класса и называется \define{конструктором}.

  \begin{extrainfo}
    В некоторых языках (C++, Objective C), где управление памятью происходит явно (явно выделяется,
    явно освобождается), наравне с конструктором у классов есть \define{деструктор}, отвечающий за
    освобождение памяти и всех ресурсов, занятых в конструкторе.
  \end{extrainfo}

  Важной особенностью некоторых свойств и методов является то, что они отвечают внутреннему
  состоянию объекта, и не должны изменяться извне. Их называют \define{приватными} (\eng{private}),
  в~отличие от \define{публичных} (\eng{public}), \ie доступных всем.

  \begin{example}
    У класса \emph{Тетрадь} есть свойства \emph{владелец} и \emph{формат}. Мы легко можем передать
    тетрадь другому владельцу, переписав значение соответствующего свойства. Но формат тетради не
    может \strong{сам} стать больше от того, что мы присвоим в свойство \emph{формат} новое
    значение, так что такое присваивание приведёт к тому, что объект будет иметь некорректное
    состояние. Поэтому свойство \emph{формат} лучше сделать приватным.
  \end{example}

  Объединение данных и кода, который их обрабатывает, а также сокрытие их и защита от
  несанкционированного использования лежат в основе \define{принципа инкапсуляции}.

  \section{Классы в Java и Ruby}

\end{document}
